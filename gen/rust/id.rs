// This file is generated by rust-protobuf 3.1.0. Do not edit
// .proto file is parsed by protoc --rust-out=...
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_results)]
#![allow(unused_mut)]

//! Generated file from `proto/imp/api/id/id.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_3_1_0;

/// *
///  Represents a DID recovery kit to back up and restore from later.
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:id.RecoveryKit)
pub struct RecoveryKit {
    // message fields
    // @@protoc_insertion_point(field:id.RecoveryKit.did)
    pub did: ::std::string::String,
    // @@protoc_insertion_point(field:id.RecoveryKit.long_form_did)
    pub long_form_did: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:id.RecoveryKit.did_derivation_path)
    pub did_derivation_path: u32,
    // @@protoc_insertion_point(field:id.RecoveryKit.key_derivations)
    pub key_derivations: ::std::vec::Vec<u32>,
    // @@protoc_insertion_point(field:id.RecoveryKit.seed)
    pub seed: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:id.RecoveryKit.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a RecoveryKit {
    fn default() -> &'a RecoveryKit {
        <RecoveryKit as ::protobuf::Message>::default_instance()
    }
}

impl RecoveryKit {
    pub fn new() -> RecoveryKit {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "did",
            |m: &RecoveryKit| { &m.did },
            |m: &mut RecoveryKit| { &mut m.did },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "long_form_did",
            |m: &RecoveryKit| { &m.long_form_did },
            |m: &mut RecoveryKit| { &mut m.long_form_did },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "did_derivation_path",
            |m: &RecoveryKit| { &m.did_derivation_path },
            |m: &mut RecoveryKit| { &mut m.did_derivation_path },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "key_derivations",
            |m: &RecoveryKit| { &m.key_derivations },
            |m: &mut RecoveryKit| { &mut m.key_derivations },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "seed",
            |m: &RecoveryKit| { &m.seed },
            |m: &mut RecoveryKit| { &mut m.seed },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<RecoveryKit>(
            "RecoveryKit",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for RecoveryKit {
    const NAME: &'static str = "RecoveryKit";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.did = is.read_string()?;
                },
                18 => {
                    self.long_form_did = ::std::option::Option::Some(is.read_string()?);
                },
                24 => {
                    self.did_derivation_path = is.read_uint32()?;
                },
                34 => {
                    is.read_repeated_packed_uint32_into(&mut self.key_derivations)?;
                },
                32 => {
                    self.key_derivations.push(is.read_uint32()?);
                },
                42 => {
                    self.seed = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.did.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.did);
        }
        if let Some(v) = self.long_form_did.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if self.did_derivation_path != 0 {
            my_size += ::protobuf::rt::uint32_size(3, self.did_derivation_path);
        }
        for value in &self.key_derivations {
            my_size += ::protobuf::rt::uint32_size(4, *value);
        };
        if !self.seed.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.seed);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.did.is_empty() {
            os.write_string(1, &self.did)?;
        }
        if let Some(v) = self.long_form_did.as_ref() {
            os.write_string(2, v)?;
        }
        if self.did_derivation_path != 0 {
            os.write_uint32(3, self.did_derivation_path)?;
        }
        for v in &self.key_derivations {
            os.write_uint32(4, *v)?;
        };
        if !self.seed.is_empty() {
            os.write_string(5, &self.seed)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> RecoveryKit {
        RecoveryKit::new()
    }

    fn clear(&mut self) {
        self.did.clear();
        self.long_form_did = ::std::option::Option::None;
        self.did_derivation_path = 0;
        self.key_derivations.clear();
        self.seed.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static RecoveryKit {
        static instance: RecoveryKit = RecoveryKit {
            did: ::std::string::String::new(),
            long_form_did: ::std::option::Option::None,
            did_derivation_path: 0,
            key_derivations: ::std::vec::Vec::new(),
            seed: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for RecoveryKit {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("RecoveryKit").unwrap()).clone()
    }
}

impl ::std::fmt::Display for RecoveryKit {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RecoveryKit {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// *
///  Represents a request to resolve a DID into a DID document.
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:id.ResolveDIDRequest)
pub struct ResolveDIDRequest {
    // message fields
    // @@protoc_insertion_point(field:id.ResolveDIDRequest.did)
    pub did: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:id.ResolveDIDRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ResolveDIDRequest {
    fn default() -> &'a ResolveDIDRequest {
        <ResolveDIDRequest as ::protobuf::Message>::default_instance()
    }
}

impl ResolveDIDRequest {
    pub fn new() -> ResolveDIDRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "did",
            |m: &ResolveDIDRequest| { &m.did },
            |m: &mut ResolveDIDRequest| { &mut m.did },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ResolveDIDRequest>(
            "ResolveDIDRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ResolveDIDRequest {
    const NAME: &'static str = "ResolveDIDRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.did = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.did.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.did);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.did.is_empty() {
            os.write_string(1, &self.did)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ResolveDIDRequest {
        ResolveDIDRequest::new()
    }

    fn clear(&mut self) {
        self.did.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ResolveDIDRequest {
        static instance: ResolveDIDRequest = ResolveDIDRequest {
            did: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ResolveDIDRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ResolveDIDRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ResolveDIDRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ResolveDIDRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// *
///  Represents a response containing the resolved DID document of the passed in DID URI.
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:id.ResolveDIDResponse)
pub struct ResolveDIDResponse {
    // message fields
    // @@protoc_insertion_point(field:id.ResolveDIDResponse.document)
    pub document: ::std::string::String,
    // @@protoc_insertion_point(field:id.ResolveDIDResponse.long_form_did)
    pub long_form_did: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:id.ResolveDIDResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ResolveDIDResponse {
    fn default() -> &'a ResolveDIDResponse {
        <ResolveDIDResponse as ::protobuf::Message>::default_instance()
    }
}

impl ResolveDIDResponse {
    pub fn new() -> ResolveDIDResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "document",
            |m: &ResolveDIDResponse| { &m.document },
            |m: &mut ResolveDIDResponse| { &mut m.document },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "long_form_did",
            |m: &ResolveDIDResponse| { &m.long_form_did },
            |m: &mut ResolveDIDResponse| { &mut m.long_form_did },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ResolveDIDResponse>(
            "ResolveDIDResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ResolveDIDResponse {
    const NAME: &'static str = "ResolveDIDResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.document = is.read_string()?;
                },
                18 => {
                    self.long_form_did = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.document.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.document);
        }
        if !self.long_form_did.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.long_form_did);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.document.is_empty() {
            os.write_string(1, &self.document)?;
        }
        if !self.long_form_did.is_empty() {
            os.write_string(2, &self.long_form_did)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ResolveDIDResponse {
        ResolveDIDResponse::new()
    }

    fn clear(&mut self) {
        self.document.clear();
        self.long_form_did.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ResolveDIDResponse {
        static instance: ResolveDIDResponse = ResolveDIDResponse {
            document: ::std::string::String::new(),
            long_form_did: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ResolveDIDResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ResolveDIDResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ResolveDIDResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ResolveDIDResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// *
///  Represents a request to store a DID document.
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:id.StoreDIDRequest)
pub struct StoreDIDRequest {
    // message fields
    // @@protoc_insertion_point(field:id.StoreDIDRequest.document)
    pub document: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:id.StoreDIDRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a StoreDIDRequest {
    fn default() -> &'a StoreDIDRequest {
        <StoreDIDRequest as ::protobuf::Message>::default_instance()
    }
}

impl StoreDIDRequest {
    pub fn new() -> StoreDIDRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "document",
            |m: &StoreDIDRequest| { &m.document },
            |m: &mut StoreDIDRequest| { &mut m.document },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<StoreDIDRequest>(
            "StoreDIDRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for StoreDIDRequest {
    const NAME: &'static str = "StoreDIDRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.document = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.document.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.document);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.document.is_empty() {
            os.write_string(1, &self.document)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> StoreDIDRequest {
        StoreDIDRequest::new()
    }

    fn clear(&mut self) {
        self.document.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static StoreDIDRequest {
        static instance: StoreDIDRequest = StoreDIDRequest {
            document: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for StoreDIDRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("StoreDIDRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for StoreDIDRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for StoreDIDRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// *
///  Represents a response containing the resolved ID of the passed in DID document.
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:id.StoreDIDResponse)
pub struct StoreDIDResponse {
    // message fields
    // @@protoc_insertion_point(field:id.StoreDIDResponse.id)
    pub id: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:id.StoreDIDResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a StoreDIDResponse {
    fn default() -> &'a StoreDIDResponse {
        <StoreDIDResponse as ::protobuf::Message>::default_instance()
    }
}

impl StoreDIDResponse {
    pub fn new() -> StoreDIDResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "id",
            |m: &StoreDIDResponse| { &m.id },
            |m: &mut StoreDIDResponse| { &mut m.id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<StoreDIDResponse>(
            "StoreDIDResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for StoreDIDResponse {
    const NAME: &'static str = "StoreDIDResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.id = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.id.is_empty() {
            os.write_string(1, &self.id)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> StoreDIDResponse {
        StoreDIDResponse::new()
    }

    fn clear(&mut self) {
        self.id.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static StoreDIDResponse {
        static instance: StoreDIDResponse = StoreDIDResponse {
            id: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for StoreDIDResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("StoreDIDResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for StoreDIDResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for StoreDIDResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// *
///  Represents a request to list DIDs stored locally.
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:id.ListDIDRequest)
pub struct ListDIDRequest {
    // special fields
    // @@protoc_insertion_point(special_field:id.ListDIDRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ListDIDRequest {
    fn default() -> &'a ListDIDRequest {
        <ListDIDRequest as ::protobuf::Message>::default_instance()
    }
}

impl ListDIDRequest {
    pub fn new() -> ListDIDRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ListDIDRequest>(
            "ListDIDRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ListDIDRequest {
    const NAME: &'static str = "ListDIDRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ListDIDRequest {
        ListDIDRequest::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ListDIDRequest {
        static instance: ListDIDRequest = ListDIDRequest {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ListDIDRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ListDIDRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ListDIDRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListDIDRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// *
///  Represents a response containing a list of the stored DIDs.
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:id.ListDIDResponse)
pub struct ListDIDResponse {
    // message fields
    // @@protoc_insertion_point(field:id.ListDIDResponse.documents)
    pub documents: ::std::vec::Vec<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:id.ListDIDResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ListDIDResponse {
    fn default() -> &'a ListDIDResponse {
        <ListDIDResponse as ::protobuf::Message>::default_instance()
    }
}

impl ListDIDResponse {
    pub fn new() -> ListDIDResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "documents",
            |m: &ListDIDResponse| { &m.documents },
            |m: &mut ListDIDResponse| { &mut m.documents },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ListDIDResponse>(
            "ListDIDResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ListDIDResponse {
    const NAME: &'static str = "ListDIDResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.documents.push(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.documents {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.documents {
            os.write_string(1, &v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ListDIDResponse {
        ListDIDResponse::new()
    }

    fn clear(&mut self) {
        self.documents.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ListDIDResponse {
        static instance: ListDIDResponse = ListDIDResponse {
            documents: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ListDIDResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ListDIDResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ListDIDResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListDIDResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:id.ServiceEndpoint)
pub struct ServiceEndpoint {
    // message fields
    // @@protoc_insertion_point(field:id.ServiceEndpoint.id)
    pub id: ::std::string::String,
    // @@protoc_insertion_point(field:id.ServiceEndpoint.type)
    pub type_: ::std::string::String,
    // @@protoc_insertion_point(field:id.ServiceEndpoint.serviceEndpoint)
    pub serviceEndpoint: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:id.ServiceEndpoint.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ServiceEndpoint {
    fn default() -> &'a ServiceEndpoint {
        <ServiceEndpoint as ::protobuf::Message>::default_instance()
    }
}

impl ServiceEndpoint {
    pub fn new() -> ServiceEndpoint {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "id",
            |m: &ServiceEndpoint| { &m.id },
            |m: &mut ServiceEndpoint| { &mut m.id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "type",
            |m: &ServiceEndpoint| { &m.type_ },
            |m: &mut ServiceEndpoint| { &mut m.type_ },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "serviceEndpoint",
            |m: &ServiceEndpoint| { &m.serviceEndpoint },
            |m: &mut ServiceEndpoint| { &mut m.serviceEndpoint },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ServiceEndpoint>(
            "ServiceEndpoint",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ServiceEndpoint {
    const NAME: &'static str = "ServiceEndpoint";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.id = is.read_string()?;
                },
                18 => {
                    self.type_ = is.read_string()?;
                },
                26 => {
                    self.serviceEndpoint = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.id);
        }
        if !self.type_.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.type_);
        }
        if !self.serviceEndpoint.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.serviceEndpoint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.id.is_empty() {
            os.write_string(1, &self.id)?;
        }
        if !self.type_.is_empty() {
            os.write_string(2, &self.type_)?;
        }
        if !self.serviceEndpoint.is_empty() {
            os.write_string(3, &self.serviceEndpoint)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ServiceEndpoint {
        ServiceEndpoint::new()
    }

    fn clear(&mut self) {
        self.id.clear();
        self.type_.clear();
        self.serviceEndpoint.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ServiceEndpoint {
        static instance: ServiceEndpoint = ServiceEndpoint {
            id: ::std::string::String::new(),
            type_: ::std::string::String::new(),
            serviceEndpoint: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ServiceEndpoint {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ServiceEndpoint").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ServiceEndpoint {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ServiceEndpoint {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// *
///  Represents a request to create a DID document.
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:id.CreateDIDRequest)
pub struct CreateDIDRequest {
    // message fields
    // @@protoc_insertion_point(field:id.CreateDIDRequest.type)
    pub type_: ::std::string::String,
    // @@protoc_insertion_point(field:id.CreateDIDRequest.serviceEndpoints)
    pub serviceEndpoints: ::std::vec::Vec<ServiceEndpoint>,
    // special fields
    // @@protoc_insertion_point(special_field:id.CreateDIDRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CreateDIDRequest {
    fn default() -> &'a CreateDIDRequest {
        <CreateDIDRequest as ::protobuf::Message>::default_instance()
    }
}

impl CreateDIDRequest {
    pub fn new() -> CreateDIDRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "type",
            |m: &CreateDIDRequest| { &m.type_ },
            |m: &mut CreateDIDRequest| { &mut m.type_ },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "serviceEndpoints",
            |m: &CreateDIDRequest| { &m.serviceEndpoints },
            |m: &mut CreateDIDRequest| { &mut m.serviceEndpoints },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CreateDIDRequest>(
            "CreateDIDRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CreateDIDRequest {
    const NAME: &'static str = "CreateDIDRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.type_ = is.read_string()?;
                },
                18 => {
                    self.serviceEndpoints.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.type_.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.type_);
        }
        for value in &self.serviceEndpoints {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.type_.is_empty() {
            os.write_string(1, &self.type_)?;
        }
        for v in &self.serviceEndpoints {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CreateDIDRequest {
        CreateDIDRequest::new()
    }

    fn clear(&mut self) {
        self.type_.clear();
        self.serviceEndpoints.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CreateDIDRequest {
        static instance: CreateDIDRequest = CreateDIDRequest {
            type_: ::std::string::String::new(),
            serviceEndpoints: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CreateDIDRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CreateDIDRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CreateDIDRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CreateDIDRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// *
///  Represents a response the document for the created DID.
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:id.CreateDIDResponse)
pub struct CreateDIDResponse {
    // message fields
    // @@protoc_insertion_point(field:id.CreateDIDResponse.document)
    pub document: ::std::string::String,
    // @@protoc_insertion_point(field:id.CreateDIDResponse.long_form_did)
    pub long_form_did: ::std::string::String,
    // @@protoc_insertion_point(field:id.CreateDIDResponse.recovery_kit)
    pub recovery_kit: ::protobuf::MessageField<RecoveryKit>,
    // special fields
    // @@protoc_insertion_point(special_field:id.CreateDIDResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CreateDIDResponse {
    fn default() -> &'a CreateDIDResponse {
        <CreateDIDResponse as ::protobuf::Message>::default_instance()
    }
}

impl CreateDIDResponse {
    pub fn new() -> CreateDIDResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "document",
            |m: &CreateDIDResponse| { &m.document },
            |m: &mut CreateDIDResponse| { &mut m.document },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "long_form_did",
            |m: &CreateDIDResponse| { &m.long_form_did },
            |m: &mut CreateDIDResponse| { &mut m.long_form_did },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, RecoveryKit>(
            "recovery_kit",
            |m: &CreateDIDResponse| { &m.recovery_kit },
            |m: &mut CreateDIDResponse| { &mut m.recovery_kit },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CreateDIDResponse>(
            "CreateDIDResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CreateDIDResponse {
    const NAME: &'static str = "CreateDIDResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.document = is.read_string()?;
                },
                18 => {
                    self.long_form_did = is.read_string()?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.recovery_kit)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.document.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.document);
        }
        if !self.long_form_did.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.long_form_did);
        }
        if let Some(v) = self.recovery_kit.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.document.is_empty() {
            os.write_string(1, &self.document)?;
        }
        if !self.long_form_did.is_empty() {
            os.write_string(2, &self.long_form_did)?;
        }
        if let Some(v) = self.recovery_kit.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CreateDIDResponse {
        CreateDIDResponse::new()
    }

    fn clear(&mut self) {
        self.document.clear();
        self.long_form_did.clear();
        self.recovery_kit.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CreateDIDResponse {
        static instance: CreateDIDResponse = CreateDIDResponse {
            document: ::std::string::String::new(),
            long_form_did: ::std::string::String::new(),
            recovery_kit: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CreateDIDResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CreateDIDResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CreateDIDResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CreateDIDResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// *
///  Represents a request to import a user's DID document.
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:id.ImportDIDRequest)
pub struct ImportDIDRequest {
    // message fields
    // @@protoc_insertion_point(field:id.ImportDIDRequest.document)
    pub document: ::std::string::String,
    // @@protoc_insertion_point(field:id.ImportDIDRequest.long_form_did)
    pub long_form_did: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:id.ImportDIDRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ImportDIDRequest {
    fn default() -> &'a ImportDIDRequest {
        <ImportDIDRequest as ::protobuf::Message>::default_instance()
    }
}

impl ImportDIDRequest {
    pub fn new() -> ImportDIDRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "document",
            |m: &ImportDIDRequest| { &m.document },
            |m: &mut ImportDIDRequest| { &mut m.document },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "long_form_did",
            |m: &ImportDIDRequest| { &m.long_form_did },
            |m: &mut ImportDIDRequest| { &mut m.long_form_did },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ImportDIDRequest>(
            "ImportDIDRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ImportDIDRequest {
    const NAME: &'static str = "ImportDIDRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.document = is.read_string()?;
                },
                18 => {
                    self.long_form_did = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.document.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.document);
        }
        if !self.long_form_did.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.long_form_did);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.document.is_empty() {
            os.write_string(1, &self.document)?;
        }
        if !self.long_form_did.is_empty() {
            os.write_string(2, &self.long_form_did)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ImportDIDRequest {
        ImportDIDRequest::new()
    }

    fn clear(&mut self) {
        self.document.clear();
        self.long_form_did.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ImportDIDRequest {
        static instance: ImportDIDRequest = ImportDIDRequest {
            document: ::std::string::String::new(),
            long_form_did: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ImportDIDRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ImportDIDRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ImportDIDRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ImportDIDRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// *
///  Represents a response after importing a user's DID document.
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:id.ImportDIDResponse)
pub struct ImportDIDResponse {
    // special fields
    // @@protoc_insertion_point(special_field:id.ImportDIDResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ImportDIDResponse {
    fn default() -> &'a ImportDIDResponse {
        <ImportDIDResponse as ::protobuf::Message>::default_instance()
    }
}

impl ImportDIDResponse {
    pub fn new() -> ImportDIDResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ImportDIDResponse>(
            "ImportDIDResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ImportDIDResponse {
    const NAME: &'static str = "ImportDIDResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ImportDIDResponse {
        ImportDIDResponse::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ImportDIDResponse {
        static instance: ImportDIDResponse = ImportDIDResponse {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ImportDIDResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ImportDIDResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ImportDIDResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ImportDIDResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// *
///  Represents a request to update a DID document.
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:id.UpdateDIDRequest)
pub struct UpdateDIDRequest {
    // message fields
    // @@protoc_insertion_point(field:id.UpdateDIDRequest.document)
    pub document: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:id.UpdateDIDRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a UpdateDIDRequest {
    fn default() -> &'a UpdateDIDRequest {
        <UpdateDIDRequest as ::protobuf::Message>::default_instance()
    }
}

impl UpdateDIDRequest {
    pub fn new() -> UpdateDIDRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "document",
            |m: &UpdateDIDRequest| { &m.document },
            |m: &mut UpdateDIDRequest| { &mut m.document },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<UpdateDIDRequest>(
            "UpdateDIDRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for UpdateDIDRequest {
    const NAME: &'static str = "UpdateDIDRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.document = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.document.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.document);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.document.is_empty() {
            os.write_string(1, &self.document)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> UpdateDIDRequest {
        UpdateDIDRequest::new()
    }

    fn clear(&mut self) {
        self.document.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static UpdateDIDRequest {
        static instance: UpdateDIDRequest = UpdateDIDRequest {
            document: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for UpdateDIDRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("UpdateDIDRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for UpdateDIDRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UpdateDIDRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// *
///  Represents a response after updating a DID document.
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:id.UpdateDIDResponse)
pub struct UpdateDIDResponse {
    // message fields
    // @@protoc_insertion_point(field:id.UpdateDIDResponse.document)
    pub document: ::std::string::String,
    // @@protoc_insertion_point(field:id.UpdateDIDResponse.long_form_did)
    pub long_form_did: ::std::string::String,
    // @@protoc_insertion_point(field:id.UpdateDIDResponse.recovery_kit)
    pub recovery_kit: ::protobuf::MessageField<RecoveryKit>,
    // special fields
    // @@protoc_insertion_point(special_field:id.UpdateDIDResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a UpdateDIDResponse {
    fn default() -> &'a UpdateDIDResponse {
        <UpdateDIDResponse as ::protobuf::Message>::default_instance()
    }
}

impl UpdateDIDResponse {
    pub fn new() -> UpdateDIDResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "document",
            |m: &UpdateDIDResponse| { &m.document },
            |m: &mut UpdateDIDResponse| { &mut m.document },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "long_form_did",
            |m: &UpdateDIDResponse| { &m.long_form_did },
            |m: &mut UpdateDIDResponse| { &mut m.long_form_did },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, RecoveryKit>(
            "recovery_kit",
            |m: &UpdateDIDResponse| { &m.recovery_kit },
            |m: &mut UpdateDIDResponse| { &mut m.recovery_kit },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<UpdateDIDResponse>(
            "UpdateDIDResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for UpdateDIDResponse {
    const NAME: &'static str = "UpdateDIDResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.document = is.read_string()?;
                },
                18 => {
                    self.long_form_did = is.read_string()?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.recovery_kit)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.document.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.document);
        }
        if !self.long_form_did.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.long_form_did);
        }
        if let Some(v) = self.recovery_kit.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.document.is_empty() {
            os.write_string(1, &self.document)?;
        }
        if !self.long_form_did.is_empty() {
            os.write_string(2, &self.long_form_did)?;
        }
        if let Some(v) = self.recovery_kit.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> UpdateDIDResponse {
        UpdateDIDResponse::new()
    }

    fn clear(&mut self) {
        self.document.clear();
        self.long_form_did.clear();
        self.recovery_kit.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static UpdateDIDResponse {
        static instance: UpdateDIDResponse = UpdateDIDResponse {
            document: ::std::string::String::new(),
            long_form_did: ::std::string::String::new(),
            recovery_kit: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for UpdateDIDResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("UpdateDIDResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for UpdateDIDResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UpdateDIDResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// *
///  Represents a request to delete a did.
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:id.DeleteDIDRequest)
pub struct DeleteDIDRequest {
    // message fields
    // @@protoc_insertion_point(field:id.DeleteDIDRequest.id)
    pub id: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:id.DeleteDIDRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a DeleteDIDRequest {
    fn default() -> &'a DeleteDIDRequest {
        <DeleteDIDRequest as ::protobuf::Message>::default_instance()
    }
}

impl DeleteDIDRequest {
    pub fn new() -> DeleteDIDRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "id",
            |m: &DeleteDIDRequest| { &m.id },
            |m: &mut DeleteDIDRequest| { &mut m.id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<DeleteDIDRequest>(
            "DeleteDIDRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for DeleteDIDRequest {
    const NAME: &'static str = "DeleteDIDRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.id = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.id.is_empty() {
            os.write_string(1, &self.id)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> DeleteDIDRequest {
        DeleteDIDRequest::new()
    }

    fn clear(&mut self) {
        self.id.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static DeleteDIDRequest {
        static instance: DeleteDIDRequest = DeleteDIDRequest {
            id: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for DeleteDIDRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("DeleteDIDRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for DeleteDIDRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeleteDIDRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// *
///  Represents a response containing the did deletion event.
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:id.DeleteDIDResponse)
pub struct DeleteDIDResponse {
    // special fields
    // @@protoc_insertion_point(special_field:id.DeleteDIDResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a DeleteDIDResponse {
    fn default() -> &'a DeleteDIDResponse {
        <DeleteDIDResponse as ::protobuf::Message>::default_instance()
    }
}

impl DeleteDIDResponse {
    pub fn new() -> DeleteDIDResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<DeleteDIDResponse>(
            "DeleteDIDResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for DeleteDIDResponse {
    const NAME: &'static str = "DeleteDIDResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> DeleteDIDResponse {
        DeleteDIDResponse::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static DeleteDIDResponse {
        static instance: DeleteDIDResponse = DeleteDIDResponse {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for DeleteDIDResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("DeleteDIDResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for DeleteDIDResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeleteDIDResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// *
///  Represents a request to backup a did.
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:id.BackupDIDRequest)
pub struct BackupDIDRequest {
    // message fields
    // @@protoc_insertion_point(field:id.BackupDIDRequest.id)
    pub id: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:id.BackupDIDRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a BackupDIDRequest {
    fn default() -> &'a BackupDIDRequest {
        <BackupDIDRequest as ::protobuf::Message>::default_instance()
    }
}

impl BackupDIDRequest {
    pub fn new() -> BackupDIDRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "id",
            |m: &BackupDIDRequest| { &m.id },
            |m: &mut BackupDIDRequest| { &mut m.id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<BackupDIDRequest>(
            "BackupDIDRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for BackupDIDRequest {
    const NAME: &'static str = "BackupDIDRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.id = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.id.is_empty() {
            os.write_string(1, &self.id)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> BackupDIDRequest {
        BackupDIDRequest::new()
    }

    fn clear(&mut self) {
        self.id.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static BackupDIDRequest {
        static instance: BackupDIDRequest = BackupDIDRequest {
            id: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for BackupDIDRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("BackupDIDRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for BackupDIDRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BackupDIDRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// *
///  Represents a response containing the did backup recovery kit.
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:id.BackupDIDResponse)
pub struct BackupDIDResponse {
    // message fields
    // @@protoc_insertion_point(field:id.BackupDIDResponse.recovery_kit)
    pub recovery_kit: ::protobuf::MessageField<RecoveryKit>,
    // special fields
    // @@protoc_insertion_point(special_field:id.BackupDIDResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a BackupDIDResponse {
    fn default() -> &'a BackupDIDResponse {
        <BackupDIDResponse as ::protobuf::Message>::default_instance()
    }
}

impl BackupDIDResponse {
    pub fn new() -> BackupDIDResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, RecoveryKit>(
            "recovery_kit",
            |m: &BackupDIDResponse| { &m.recovery_kit },
            |m: &mut BackupDIDResponse| { &mut m.recovery_kit },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<BackupDIDResponse>(
            "BackupDIDResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for BackupDIDResponse {
    const NAME: &'static str = "BackupDIDResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.recovery_kit)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.recovery_kit.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.recovery_kit.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> BackupDIDResponse {
        BackupDIDResponse::new()
    }

    fn clear(&mut self) {
        self.recovery_kit.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static BackupDIDResponse {
        static instance: BackupDIDResponse = BackupDIDResponse {
            recovery_kit: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for BackupDIDResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("BackupDIDResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for BackupDIDResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BackupDIDResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// *
///  Represents a request to recover a did with the recovery kit.
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:id.RecoverDIDRequest)
pub struct RecoverDIDRequest {
    // message fields
    // @@protoc_insertion_point(field:id.RecoverDIDRequest.recovery_kit)
    pub recovery_kit: ::protobuf::MessageField<RecoveryKit>,
    // @@protoc_insertion_point(field:id.RecoverDIDRequest.passphrase)
    pub passphrase: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:id.RecoverDIDRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a RecoverDIDRequest {
    fn default() -> &'a RecoverDIDRequest {
        <RecoverDIDRequest as ::protobuf::Message>::default_instance()
    }
}

impl RecoverDIDRequest {
    pub fn new() -> RecoverDIDRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, RecoveryKit>(
            "recovery_kit",
            |m: &RecoverDIDRequest| { &m.recovery_kit },
            |m: &mut RecoverDIDRequest| { &mut m.recovery_kit },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "passphrase",
            |m: &RecoverDIDRequest| { &m.passphrase },
            |m: &mut RecoverDIDRequest| { &mut m.passphrase },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<RecoverDIDRequest>(
            "RecoverDIDRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for RecoverDIDRequest {
    const NAME: &'static str = "RecoverDIDRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.recovery_kit)?;
                },
                18 => {
                    self.passphrase = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.recovery_kit.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.passphrase.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.recovery_kit.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.passphrase.as_ref() {
            os.write_string(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> RecoverDIDRequest {
        RecoverDIDRequest::new()
    }

    fn clear(&mut self) {
        self.recovery_kit.clear();
        self.passphrase = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static RecoverDIDRequest {
        static instance: RecoverDIDRequest = RecoverDIDRequest {
            recovery_kit: ::protobuf::MessageField::none(),
            passphrase: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for RecoverDIDRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("RecoverDIDRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for RecoverDIDRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RecoverDIDRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// *
///  Represents a response containing the did recovery result.
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:id.RecoverDIDResponse)
pub struct RecoverDIDResponse {
    // special fields
    // @@protoc_insertion_point(special_field:id.RecoverDIDResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a RecoverDIDResponse {
    fn default() -> &'a RecoverDIDResponse {
        <RecoverDIDResponse as ::protobuf::Message>::default_instance()
    }
}

impl RecoverDIDResponse {
    pub fn new() -> RecoverDIDResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<RecoverDIDResponse>(
            "RecoverDIDResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for RecoverDIDResponse {
    const NAME: &'static str = "RecoverDIDResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> RecoverDIDResponse {
        RecoverDIDResponse::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static RecoverDIDResponse {
        static instance: RecoverDIDResponse = RecoverDIDResponse {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for RecoverDIDResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("RecoverDIDResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for RecoverDIDResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RecoverDIDResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x19proto/imp/api/id/id.proto\x12\x02id\x1a\x1cgoogle/api/annotations.\
    proto\x1a.protoc-gen-openapiv2/options/annotations.proto\"\xc7\x01\n\x0b\
    RecoveryKit\x12\x10\n\x03did\x18\x01\x20\x01(\tR\x03did\x12'\n\rlong_for\
    m_did\x18\x02\x20\x01(\tH\0R\x0blongFormDid\x88\x01\x01\x12.\n\x13did_de\
    rivation_path\x18\x03\x20\x01(\rR\x11didDerivationPath\x12'\n\x0fkey_der\
    ivations\x18\x04\x20\x03(\rR\x0ekeyDerivations\x12\x12\n\x04seed\x18\x05\
    \x20\x01(\tR\x04seedB\x10\n\x0e_long_form_did\"%\n\x11ResolveDIDRequest\
    \x12\x10\n\x03did\x18\x01\x20\x01(\tR\x03did\"T\n\x12ResolveDIDResponse\
    \x12\x1a\n\x08document\x18\x01\x20\x01(\tR\x08document\x12\"\n\rlong_for\
    m_did\x18\x02\x20\x01(\tR\x0blongFormDid\"-\n\x0fStoreDIDRequest\x12\x1a\
    \n\x08document\x18\x01\x20\x01(\tR\x08document\"\"\n\x10StoreDIDResponse\
    \x12\x0e\n\x02id\x18\x01\x20\x01(\tR\x02id\"\x10\n\x0eListDIDRequest\"/\
    \n\x0fListDIDResponse\x12\x1c\n\tdocuments\x18\x01\x20\x03(\tR\tdocument\
    s\"_\n\x0fServiceEndpoint\x12\x0e\n\x02id\x18\x01\x20\x01(\tR\x02id\x12\
    \x12\n\x04type\x18\x02\x20\x01(\tR\x04type\x12(\n\x0fserviceEndpoint\x18\
    \x03\x20\x01(\tR\x0fserviceEndpoint\"g\n\x10CreateDIDRequest\x12\x12\n\
    \x04type\x18\x01\x20\x01(\tR\x04type\x12?\n\x10serviceEndpoints\x18\x02\
    \x20\x03(\x0b2\x13.id.ServiceEndpointR\x10serviceEndpoints\"\x87\x01\n\
    \x11CreateDIDResponse\x12\x1a\n\x08document\x18\x01\x20\x01(\tR\x08docum\
    ent\x12\"\n\rlong_form_did\x18\x02\x20\x01(\tR\x0blongFormDid\x122\n\x0c\
    recovery_kit\x18\x03\x20\x01(\x0b2\x0f.id.RecoveryKitR\x0brecoveryKit\"R\
    \n\x10ImportDIDRequest\x12\x1a\n\x08document\x18\x01\x20\x01(\tR\x08docu\
    ment\x12\"\n\rlong_form_did\x18\x02\x20\x01(\tR\x0blongFormDid\"\x13\n\
    \x11ImportDIDResponse\".\n\x10UpdateDIDRequest\x12\x1a\n\x08document\x18\
    \x01\x20\x01(\tR\x08document\"\x9d\x01\n\x11UpdateDIDResponse\x12\x1a\n\
    \x08document\x18\x01\x20\x01(\tR\x08document\x12\"\n\rlong_form_did\x18\
    \x02\x20\x01(\tR\x0blongFormDid\x127\n\x0crecovery_kit\x18\x03\x20\x01(\
    \x0b2\x0f.id.RecoveryKitH\0R\x0brecoveryKit\x88\x01\x01B\x0f\n\r_recover\
    y_kit\"\"\n\x10DeleteDIDRequest\x12\x0e\n\x02id\x18\x01\x20\x01(\tR\x02i\
    d\"\x13\n\x11DeleteDIDResponse\"\"\n\x10BackupDIDRequest\x12\x0e\n\x02id\
    \x18\x01\x20\x01(\tR\x02id\"G\n\x11BackupDIDResponse\x122\n\x0crecovery_\
    kit\x18\x01\x20\x01(\x0b2\x0f.id.RecoveryKitR\x0brecoveryKit\"{\n\x11Rec\
    overDIDRequest\x122\n\x0crecovery_kit\x18\x01\x20\x01(\x0b2\x0f.id.Recov\
    eryKitR\x0brecoveryKit\x12#\n\npassphrase\x18\x02\x20\x01(\tH\0R\npassph\
    rase\x88\x01\x01B\r\n\x0b_passphrase\"\x14\n\x12RecoverDIDResponse2\xb0\
    \x05\n\x02ID\x12Y\n\nResolveDID\x12\x15.id.ResolveDIDRequest\x1a\x16.id.\
    ResolveDIDResponse\"\x1c\x82\xd3\xe4\x93\x02\x16\"\x11/v1/id/resolveDID:\
    \x01*\x12J\n\x07ListDID\x12\x12.id.ListDIDRequest\x1a\x13.id.ListDIDResp\
    onse\"\x16\x82\xd3\xe4\x93\x02\x10\x12\x0e/v1/id/listDID\x12U\n\tCreateD\
    ID\x12\x14.id.CreateDIDRequest\x1a\x15.id.CreateDIDResponse\"\x1b\x82\
    \xd3\xe4\x93\x02\x15\"\x10/v1/id/createDID:\x01*\x12U\n\tImportDID\x12\
    \x14.id.ImportDIDRequest\x1a\x15.id.ImportDIDResponse\"\x1b\x82\xd3\xe4\
    \x93\x02\x15\"\x10/v1/id/importDID:\x01*\x12U\n\tUpdateDID\x12\x14.id.Up\
    dateDIDRequest\x1a\x15.id.UpdateDIDResponse\"\x1b\x82\xd3\xe4\x93\x02\
    \x15\"\x10/v1/id/updateDID:\x01*\x12M\n\tDeleteDID\x12\x14.id.DeleteDIDR\
    equest\x1a\x15.id.DeleteDIDResponse\"\x13\x82\xd3\xe4\x93\x02\r*\x0b/v1/\
    id/{id}\x12W\n\tBackupDID\x12\x14.id.BackupDIDRequest\x1a\x15.id.BackupD\
    IDResponse\"\x1d\x82\xd3\xe4\x93\x02\x17\"\x12/v1/id/{id}/backup:\x01*\
    \x12V\n\nRecoverDID\x12\x15.id.RecoverDIDRequest\x1a\x16.id.RecoverDIDRe\
    sponse\"\x19\x82\xd3\xe4\x93\x02\x13\"\x0e/v1/id/recover:\x01*B\xb4\x02Z\
    #github.com/imperviousai/freeimp/gen\x92A\x8b\x02\x12:\n\x0bID\x20Servic\
    es\"&\n\rImpervious\x20AI\x12\x15https://impervious.ai2\x031.0*\x03\x01\
    \x02\x042\x10application/json:\x10application/jsonZa\n_\n\x07api_key\x12\
    T\x08\x02\x125An\x20API\x20key\x20generated\x20by\x20the\x20daemon\x20fo\
    r\x20authentication\x1a\x17Grpc-Metadata-X-API-KEY\x20\x03b\r\n\x0b\n\
    \x07api_key\x12\0r2\n\x14Documentation\x20on\x20IMP\x12\x1ahttps://docs.\
    impervious.aiJ\xe22\n\x07\x12\x05\x01\0\x8e\x02\x01\n7\n\x01\x0c\x12\x03\
    \x01\0\x12\x1a-/\x20Allows\x20for\x20ID\x20actions\x20for\x20Impervious\
    \x20nodes\n\n\x08\n\x01\x02\x12\x03\x03\0\x0b\n\x08\n\x01\x08\x12\x03\
    \x05\0:\n\t\n\x02\x08\x0b\x12\x03\x05\0:\n\t\n\x02\x03\0\x12\x03\x07\0&\
    \n\t\n\x02\x03\x01\x12\x03\x08\08\n\t\n\x01\x08\x12\x04\n\0,\x02\n\x0b\n\
    \x03\x08\x92\x08\x12\x04\n\0,\x02\nF\n\x02\x06\0\x12\x041\0y\x01\x1a:*\n\
    \x20ID\x20service\x20allows\x20ID\x20actions\x20from\x20the\x20Imperviou\
    s\x20node.\n\n\n\n\x03\x06\0\x01\x12\x031\x08\n\ne\n\x04\x06\0\x02\0\x12\
    \x045\x08:\t\x1aW*\n\x20ResolveDID\x20resolves\x20a\x20DID\x20URI\x20and\
    \x20returns\x20a\x20DID\x20document\x20representing\x20the\x20identity.\
    \n\n\x0c\n\x05\x06\0\x02\0\x01\x12\x035\x0c\x16\n\x0c\n\x05\x06\0\x02\0\
    \x02\x12\x035\x17(\n\x0c\n\x05\x06\0\x02\0\x03\x12\x0353E\n\r\n\x05\x06\
    \0\x02\0\x04\x12\x046\x109\x12\n\x11\n\t\x06\0\x02\0\x04\xb0\xca\xbc\"\
    \x12\x046\x109\x12\n?\n\x04\x06\0\x02\x01\x12\x04?\x08C\t\x1a1*\n\x20Lis\
    tDID\x20lists\x20all\x20of\x20the\x20DIDs\x20stored\x20locally.\n\n\x0c\
    \n\x05\x06\0\x02\x01\x01\x12\x03?\x0c\x13\n\x0c\n\x05\x06\0\x02\x01\x02\
    \x12\x03?\x14\"\n\x0c\n\x05\x06\0\x02\x01\x03\x12\x03?-<\n\r\n\x05\x06\0\
    \x02\x01\x04\x12\x04@\x10B\x12\n\x11\n\t\x06\0\x02\x01\x04\xb0\xca\xbc\"\
    \x12\x04@\x10B\x12\nR\n\x04\x06\0\x02\x02\x12\x04H\x08M\t\x1aD*\n\x20Cre\
    ateDID\x20creates\x20a\x20DID\x20for\x20the\x20user\x20with\x20the\x20gi\
    ven\x20information.\n\n\x0c\n\x05\x06\0\x02\x02\x01\x12\x03H\x0c\x15\n\
    \x0c\n\x05\x06\0\x02\x02\x02\x12\x03H\x16&\n\x0c\n\x05\x06\0\x02\x02\x03\
    \x12\x03H1B\n\r\n\x05\x06\0\x02\x02\x04\x12\x04I\x10L\x12\n\x11\n\t\x06\
    \0\x02\x02\x04\xb0\xca\xbc\"\x12\x04I\x10L\x12\nM\n\x04\x06\0\x02\x03\
    \x12\x04R\x08W\t\x1a?*\n\x20ImportDID\x20imports\x20a\x20DID\x20document\
    \x20which\x20belongs\x20to\x20the\x20user.\n\n\x0c\n\x05\x06\0\x02\x03\
    \x01\x12\x03R\x0c\x15\n\x0c\n\x05\x06\0\x02\x03\x02\x12\x03R\x16&\n\x0c\
    \n\x05\x06\0\x02\x03\x03\x12\x03R1B\n\r\n\x05\x06\0\x02\x03\x04\x12\x04S\
    \x10V\x12\n\x11\n\t\x06\0\x02\x03\x04\xb0\xca\xbc\"\x12\x04S\x10V\x12\nI\
    \n\x04\x06\0\x02\x04\x12\x04\\\x08a\t\x1a;*\n\x20UpdateDID\x20updates\
    \x20a\x20DID\x20document\x20with\x20a\x20patch\x20document.\n\n\x0c\n\
    \x05\x06\0\x02\x04\x01\x12\x03\\\x0c\x15\n\x0c\n\x05\x06\0\x02\x04\x02\
    \x12\x03\\\x16&\n\x0c\n\x05\x06\0\x02\x04\x03\x12\x03\\1B\n\r\n\x05\x06\
    \0\x02\x04\x04\x12\x04]\x10`\x12\n\x11\n\t\x06\0\x02\x04\x04\xb0\xca\xbc\
    \"\x12\x04]\x10`\x12\n7\n\x04\x06\0\x02\x05\x12\x04f\x08j\t\x1a)*\n\x20D\
    eleteDID\x20will\x20delete\x20a\x20specific\x20did.\n\n\x0c\n\x05\x06\0\
    \x02\x05\x01\x12\x03f\x0c\x15\n\x0c\n\x05\x06\0\x02\x05\x02\x12\x03f\x16\
    &\n\x0c\n\x05\x06\0\x02\x05\x03\x12\x03f1B\n\r\n\x05\x06\0\x02\x05\x04\
    \x12\x04g\x10i\x12\n\x11\n\t\x06\0\x02\x05\x04\xb0\xca\xbc\"\x12\x04g\
    \x10i\x12\n\x0c\n\x04\x06\0\x02\x06\x12\x04l\x08q\t\n\x0c\n\x05\x06\0\
    \x02\x06\x01\x12\x03l\x0c\x15\n\x0c\n\x05\x06\0\x02\x06\x02\x12\x03l\x16\
    &\n\x0c\n\x05\x06\0\x02\x06\x03\x12\x03l1B\n\r\n\x05\x06\0\x02\x06\x04\
    \x12\x04m\x10p\x12\n\x11\n\t\x06\0\x02\x06\x04\xb0\xca\xbc\"\x12\x04m\
    \x10p\x12\n\x0c\n\x04\x06\0\x02\x07\x12\x04s\x08x\t\n\x0c\n\x05\x06\0\
    \x02\x07\x01\x12\x03s\x0c\x16\n\x0c\n\x05\x06\0\x02\x07\x02\x12\x03s\x17\
    (\n\x0c\n\x05\x06\0\x02\x07\x03\x12\x03s3E\n\r\n\x05\x06\0\x02\x07\x04\
    \x12\x04t\x10w\x12\n\x11\n\t\x06\0\x02\x07\x04\xb0\xca\xbc\"\x12\x04t\
    \x10w\x12\nQ\n\x02\x04\0\x12\x05~\0\x84\x01\x01\x1aD*\n\x20Represents\
    \x20a\x20DID\x20recovery\x20kit\x20to\x20back\x20up\x20and\x20restore\
    \x20from\x20later.\n\n\n\n\x03\x04\0\x01\x12\x03~\x08\x13\n/\n\x04\x04\0\
    \x02\0\x12\x03\x7f\x08\x17\"\"\x20The\x20DID\x20this\x20recovery\x20kit\
    \x20is\x20for\n\n\x0c\n\x05\x04\0\x02\0\x05\x12\x03\x7f\x08\x0e\n\x0c\n\
    \x05\x04\0\x02\0\x01\x12\x03\x7f\x0f\x12\n\x0c\n\x05\x04\0\x02\0\x03\x12\
    \x03\x7f\x15\x16\nj\n\x04\x04\0\x02\x01\x12\x04\x80\x01\x08*\"\\\x20The\
    \x20long\x20form\x20DID\x20with\x20the\x20document/patches\x20encoded\
    \x20into\x20the\x20DID.\x20Only\x20necessary\x20for\x20PEER.\n\n\r\n\x05\
    \x04\0\x02\x01\x04\x12\x04\x80\x01\x08\x10\n\r\n\x05\x04\0\x02\x01\x05\
    \x12\x04\x80\x01\x11\x17\n\r\n\x05\x04\0\x02\x01\x01\x12\x04\x80\x01\x18\
    %\n\r\n\x05\x04\0\x02\x01\x03\x12\x04\x80\x01()\n6\n\x04\x04\0\x02\x02\
    \x12\x04\x81\x01\x08'\"(\x20The\x20parent\x20derivation\x20path\x20for\
    \x20the\x20DID\n\n\r\n\x05\x04\0\x02\x02\x05\x12\x04\x81\x01\x08\x0e\n\r\
    \n\x05\x04\0\x02\x02\x01\x12\x04\x81\x01\x0f\"\n\r\n\x05\x04\0\x02\x02\
    \x03\x12\x04\x81\x01%&\n<\n\x04\x04\0\x02\x03\x12\x04\x82\x01\x08,\".\
    \x20Each\x20key\x20derivation\x20path\x20created\x20under\x20a\x20DID\n\
    \n\r\n\x05\x04\0\x02\x03\x04\x12\x04\x82\x01\x08\x10\n\r\n\x05\x04\0\x02\
    \x03\x05\x12\x04\x82\x01\x11\x17\n\r\n\x05\x04\0\x02\x03\x01\x12\x04\x82\
    \x01\x18'\n\r\n\x05\x04\0\x02\x03\x03\x12\x04\x82\x01*+\n3\n\x04\x04\0\
    \x02\x04\x12\x04\x83\x01\x08\x18\"%\x20The\x20seed\x20words\x20backing\
    \x20the\x20identity\n\n\r\n\x05\x04\0\x02\x04\x05\x12\x04\x83\x01\x08\
    \x0e\n\r\n\x05\x04\0\x02\x04\x01\x12\x04\x83\x01\x0f\x13\n\r\n\x05\x04\0\
    \x02\x04\x03\x12\x04\x83\x01\x16\x17\nL\n\x02\x04\x01\x12\x06\x89\x01\0\
    \x8b\x01\x01\x1a>*\n\x20Represents\x20a\x20request\x20to\x20resolve\x20a\
    \x20DID\x20into\x20a\x20DID\x20document.\n\n\x0b\n\x03\x04\x01\x01\x12\
    \x04\x89\x01\x08\x19\n&\n\x04\x04\x01\x02\0\x12\x04\x8a\x01\x08\x17\"\
    \x18\x20The\x20DID\x20URI\x20to\x20resolve\n\n\r\n\x05\x04\x01\x02\0\x05\
    \x12\x04\x8a\x01\x08\x0e\n\r\n\x05\x04\x01\x02\0\x01\x12\x04\x8a\x01\x0f\
    \x12\n\r\n\x05\x04\x01\x02\0\x03\x12\x04\x8a\x01\x15\x16\nf\n\x02\x04\
    \x02\x12\x06\x90\x01\0\x93\x01\x01\x1aX*\n\x20Represents\x20a\x20respons\
    e\x20containing\x20the\x20resolved\x20DID\x20document\x20of\x20the\x20pa\
    ssed\x20in\x20DID\x20URI.\n\n\x0b\n\x03\x04\x02\x01\x12\x04\x90\x01\x08\
    \x1a\n)\n\x04\x04\x02\x02\0\x12\x04\x91\x01\x08\x1c\"\x1b\x20The\x20reso\
    lved\x20DID\x20document\n\n\r\n\x05\x04\x02\x02\0\x05\x12\x04\x91\x01\
    \x08\x0e\n\r\n\x05\x04\x02\x02\0\x01\x12\x04\x91\x01\x0f\x17\n\r\n\x05\
    \x04\x02\x02\0\x03\x12\x04\x91\x01\x1a\x1b\nz\n\x04\x04\x02\x02\x01\x12\
    \x04\x92\x01\x08!\"l\x20The\x20long\x20form\x20DID\x20string\x20with\x20\
    `initialState`\x20and/or\x20`signedIetfJsonPatch`\x20query\x20parameters\
    \x20encoded\x20inline.\n\n\r\n\x05\x04\x02\x02\x01\x05\x12\x04\x92\x01\
    \x08\x0e\n\r\n\x05\x04\x02\x02\x01\x01\x12\x04\x92\x01\x0f\x1c\n\r\n\x05\
    \x04\x02\x02\x01\x03\x12\x04\x92\x01\x1f\x20\n?\n\x02\x04\x03\x12\x06\
    \x98\x01\0\x9a\x01\x01\x1a1*\n\x20Represents\x20a\x20request\x20to\x20st\
    ore\x20a\x20DID\x20document.\n\n\x0b\n\x03\x04\x03\x01\x12\x04\x98\x01\
    \x08\x17\n)\n\x04\x04\x03\x02\0\x12\x04\x99\x01\x08\x1c\"\x1b\x20The\x20\
    DID\x20document\x20to\x20store\n\n\r\n\x05\x04\x03\x02\0\x05\x12\x04\x99\
    \x01\x08\x0e\n\r\n\x05\x04\x03\x02\0\x01\x12\x04\x99\x01\x0f\x17\n\r\n\
    \x05\x04\x03\x02\0\x03\x12\x04\x99\x01\x1a\x1b\na\n\x02\x04\x04\x12\x06\
    \x9f\x01\0\xa1\x01\x01\x1aS*\n\x20Represents\x20a\x20response\x20contain\
    ing\x20the\x20resolved\x20ID\x20of\x20the\x20passed\x20in\x20DID\x20docu\
    ment.\n\n\x0b\n\x03\x04\x04\x01\x12\x04\x9f\x01\x08\x18\n-\n\x04\x04\x04\
    \x02\0\x12\x04\xa0\x01\x08\x16\"\x1f\x20The\x20resolved\x20DID\x20docume\
    nt\x20ID.\n\n\r\n\x05\x04\x04\x02\0\x05\x12\x04\xa0\x01\x08\x0e\n\r\n\
    \x05\x04\x04\x02\0\x01\x12\x04\xa0\x01\x0f\x11\n\r\n\x05\x04\x04\x02\0\
    \x03\x12\x04\xa0\x01\x14\x15\nC\n\x02\x04\x05\x12\x06\xa6\x01\0\xa7\x01\
    \x01\x1a5*\n\x20Represents\x20a\x20request\x20to\x20list\x20DIDs\x20stor\
    ed\x20locally.\n\n\x0b\n\x03\x04\x05\x01\x12\x04\xa6\x01\x08\x16\nM\n\
    \x02\x04\x06\x12\x06\xac\x01\0\xae\x01\x01\x1a?*\n\x20Represents\x20a\
    \x20response\x20containing\x20a\x20list\x20of\x20the\x20stored\x20DIDs.\
    \n\n\x0b\n\x03\x04\x06\x01\x12\x04\xac\x01\x08\x17\n(\n\x04\x04\x06\x02\
    \0\x12\x04\xad\x01\x08&\"\x1a\x20The\x20stored\x20DID\x20documents\n\n\r\
    \n\x05\x04\x06\x02\0\x04\x12\x04\xad\x01\x08\x10\n\r\n\x05\x04\x06\x02\0\
    \x05\x12\x04\xad\x01\x11\x17\n\r\n\x05\x04\x06\x02\0\x01\x12\x04\xad\x01\
    \x18!\n\r\n\x05\x04\x06\x02\0\x03\x12\x04\xad\x01$%\n\x0c\n\x02\x04\x07\
    \x12\x06\xb0\x01\0\xb4\x01\x01\n\x0b\n\x03\x04\x07\x01\x12\x04\xb0\x01\
    \x08\x17\n.\n\x04\x04\x07\x02\0\x12\x04\xb1\x01\x08\x16\"\x20\x20The\x20\
    ID\x20of\x20the\x20service\x20endpoint\n\n\r\n\x05\x04\x07\x02\0\x05\x12\
    \x04\xb1\x01\x08\x0e\n\r\n\x05\x04\x07\x02\0\x01\x12\x04\xb1\x01\x0f\x11\
    \n\r\n\x05\x04\x07\x02\0\x03\x12\x04\xb1\x01\x14\x15\n0\n\x04\x04\x07\
    \x02\x01\x12\x04\xb2\x01\x08\x18\"\"\x20The\x20type\x20of\x20the\x20serv\
    ice\x20endpoint\n\n\r\n\x05\x04\x07\x02\x01\x05\x12\x04\xb2\x01\x08\x0e\
    \n\r\n\x05\x04\x07\x02\x01\x01\x12\x04\xb2\x01\x0f\x13\n\r\n\x05\x04\x07\
    \x02\x01\x03\x12\x04\xb2\x01\x16\x17\n'\n\x04\x04\x07\x02\x02\x12\x04\
    \xb3\x01\x08#\"\x19\x20The\x20serviceEndpoint\x20URI\n\n\r\n\x05\x04\x07\
    \x02\x02\x05\x12\x04\xb3\x01\x08\x0e\n\r\n\x05\x04\x07\x02\x02\x01\x12\
    \x04\xb3\x01\x0f\x1e\n\r\n\x05\x04\x07\x02\x02\x03\x12\x04\xb3\x01!\"\n@\
    \n\x02\x04\x08\x12\x06\xb9\x01\0\xbc\x01\x01\x1a2*\n\x20Represents\x20a\
    \x20request\x20to\x20create\x20a\x20DID\x20document.\n\n\x0b\n\x03\x04\
    \x08\x01\x12\x04\xb9\x01\x08\x18\n&\n\x04\x04\x08\x02\0\x12\x04\xba\x01\
    \x08\x18\"\x18\x20The\x20DID\x20type\x20to\x20create\n\n\r\n\x05\x04\x08\
    \x02\0\x05\x12\x04\xba\x01\x08\x0e\n\r\n\x05\x04\x08\x02\0\x01\x12\x04\
    \xba\x01\x0f\x13\n\r\n\x05\x04\x08\x02\0\x03\x12\x04\xba\x01\x16\x17\nB\
    \n\x04\x04\x08\x02\x01\x12\x04\xbb\x01\x086\"4\x20A\x20list\x20of\x20ser\
    vice\x20endpoints\x20to\x20create\x20the\x20DID\x20with\n\n\r\n\x05\x04\
    \x08\x02\x01\x04\x12\x04\xbb\x01\x08\x10\n\r\n\x05\x04\x08\x02\x01\x06\
    \x12\x04\xbb\x01\x11\x20\n\r\n\x05\x04\x08\x02\x01\x01\x12\x04\xbb\x01!1\
    \n\r\n\x05\x04\x08\x02\x01\x03\x12\x04\xbb\x0145\nI\n\x02\x04\t\x12\x06\
    \xc1\x01\0\xc5\x01\x01\x1a;*\n\x20Represents\x20a\x20response\x20the\x20\
    document\x20for\x20the\x20created\x20DID.\n\n\x0b\n\x03\x04\t\x01\x12\
    \x04\xc1\x01\x08\x19\n,\n\x04\x04\t\x02\0\x12\x04\xc2\x01\x08\x1c\"\x1e\
    \x20The\x20created\x20DID\x20document\x20ID.\n\n\r\n\x05\x04\t\x02\0\x05\
    \x12\x04\xc2\x01\x08\x0e\n\r\n\x05\x04\t\x02\0\x01\x12\x04\xc2\x01\x0f\
    \x17\n\r\n\x05\x04\t\x02\0\x03\x12\x04\xc2\x01\x1a\x1b\nz\n\x04\x04\t\
    \x02\x01\x12\x04\xc3\x01\x08!\"l\x20The\x20long\x20form\x20DID\x20string\
    \x20with\x20`initialState`\x20and/or\x20`signedIetfJsonPatch`\x20query\
    \x20parameters\x20encoded\x20inline.\n\n\r\n\x05\x04\t\x02\x01\x05\x12\
    \x04\xc3\x01\x08\x0e\n\r\n\x05\x04\t\x02\x01\x01\x12\x04\xc3\x01\x0f\x1c\
    \n\r\n\x05\x04\t\x02\x01\x03\x12\x04\xc3\x01\x1f\x20\n3\n\x04\x04\t\x02\
    \x02\x12\x04\xc4\x01\x08%\"%\x20The\x20recovery\x20kit\x20of\x20the\x20c\
    reated\x20DID\n\n\r\n\x05\x04\t\x02\x02\x06\x12\x04\xc4\x01\x08\x13\n\r\
    \n\x05\x04\t\x02\x02\x01\x12\x04\xc4\x01\x14\x20\n\r\n\x05\x04\t\x02\x02\
    \x03\x12\x04\xc4\x01#$\nG\n\x02\x04\n\x12\x06\xca\x01\0\xcd\x01\x01\x1a9\
    *\n\x20Represents\x20a\x20request\x20to\x20import\x20a\x20user's\x20DID\
    \x20document.\n\n\x0b\n\x03\x04\n\x01\x12\x04\xca\x01\x08\x18\nS\n\x04\
    \x04\n\x02\0\x12\x04\xcb\x01\x08\x1c\"E\x20The\x20DID\x20document\x20to\
    \x20import,\x20optional\x20if\x20`long_form_did`\x20is\x20present.\n\n\r\
    \n\x05\x04\n\x02\0\x05\x12\x04\xcb\x01\x08\x0e\n\r\n\x05\x04\n\x02\0\x01\
    \x12\x04\xcb\x01\x0f\x17\n\r\n\x05\x04\n\x02\0\x03\x12\x04\xcb\x01\x1a\
    \x1b\nz\n\x04\x04\n\x02\x01\x12\x04\xcc\x01\x08!\"l\x20The\x20long\x20fo\
    rm\x20DID\x20string\x20with\x20`initialState`\x20and/or\x20`signedIetfJs\
    onPatch`\x20query\x20parameters\x20encoded\x20inline.\n\n\r\n\x05\x04\n\
    \x02\x01\x05\x12\x04\xcc\x01\x08\x0e\n\r\n\x05\x04\n\x02\x01\x01\x12\x04\
    \xcc\x01\x0f\x1c\n\r\n\x05\x04\n\x02\x01\x03\x12\x04\xcc\x01\x1f\x20\nN\
    \n\x02\x04\x0b\x12\x06\xd2\x01\0\xd4\x01\x01\x1a@*\n\x20Represents\x20a\
    \x20response\x20after\x20importing\x20a\x20user's\x20DID\x20document.\n\
    \n\x0b\n\x03\x04\x0b\x01\x12\x04\xd2\x01\x08\x19\n@\n\x02\x04\x0c\x12\
    \x06\xd9\x01\0\xdb\x01\x01\x1a2*\n\x20Represents\x20a\x20request\x20to\
    \x20update\x20a\x20DID\x20document.\n\n\x0b\n\x03\x04\x0c\x01\x12\x04\
    \xd9\x01\x08\x18\n;\n\x04\x04\x0c\x02\0\x12\x04\xda\x01\x08\x1c\"-\x20Th\
    e\x20DID\x20document\x20patch\x20to\x20use\x20as\x20the\x20update\n\n\r\
    \n\x05\x04\x0c\x02\0\x05\x12\x04\xda\x01\x08\x0e\n\r\n\x05\x04\x0c\x02\0\
    \x01\x12\x04\xda\x01\x0f\x17\n\r\n\x05\x04\x0c\x02\0\x03\x12\x04\xda\x01\
    \x1a\x1b\nF\n\x02\x04\r\x12\x06\xe0\x01\0\xe4\x01\x01\x1a8*\n\x20Represe\
    nts\x20a\x20response\x20after\x20updating\x20a\x20DID\x20document.\n\n\
    \x0b\n\x03\x04\r\x01\x12\x04\xe0\x01\x08\x19\n,\n\x04\x04\r\x02\0\x12\
    \x04\xe1\x01\x08\x1c\"\x1e\x20The\x20updated\x20DID\x20document\x20ID.\n\
    \n\r\n\x05\x04\r\x02\0\x05\x12\x04\xe1\x01\x08\x0e\n\r\n\x05\x04\r\x02\0\
    \x01\x12\x04\xe1\x01\x0f\x17\n\r\n\x05\x04\r\x02\0\x03\x12\x04\xe1\x01\
    \x1a\x1b\nz\n\x04\x04\r\x02\x01\x12\x04\xe2\x01\x08!\"l\x20The\x20long\
    \x20form\x20DID\x20string\x20with\x20`initialState`\x20and/or\x20`signed\
    IetfJsonPatch`\x20query\x20parameters\x20encoded\x20inline.\n\n\r\n\x05\
    \x04\r\x02\x01\x05\x12\x04\xe2\x01\x08\x0e\n\r\n\x05\x04\r\x02\x01\x01\
    \x12\x04\xe2\x01\x0f\x1c\n\r\n\x05\x04\r\x02\x01\x03\x12\x04\xe2\x01\x1f\
    \x20\nN\n\x04\x04\r\x02\x02\x12\x04\xe3\x01\x08.\"@\x20The\x20recovery\
    \x20kit\x20of\x20the\x20updated\x20DID.\x20Only\x20needed\x20on\x20Peer\
    \x20DIDs.\n\n\r\n\x05\x04\r\x02\x02\x04\x12\x04\xe3\x01\x08\x10\n\r\n\
    \x05\x04\r\x02\x02\x06\x12\x04\xe3\x01\x11\x1c\n\r\n\x05\x04\r\x02\x02\
    \x01\x12\x04\xe3\x01\x1d)\n\r\n\x05\x04\r\x02\x02\x03\x12\x04\xe3\x01,-\
    \n7\n\x02\x04\x0e\x12\x06\xe9\x01\0\xeb\x01\x01\x1a)*\n\x20Represents\
    \x20a\x20request\x20to\x20delete\x20a\x20did.\n\n\x0b\n\x03\x04\x0e\x01\
    \x12\x04\xe9\x01\x08\x18\n+\n\x04\x04\x0e\x02\0\x12\x04\xea\x01\x08\x16\
    \"\x1d\x20The\x20ID\x20of\x20the\x20did\x20to\x20delete\n\n\r\n\x05\x04\
    \x0e\x02\0\x05\x12\x04\xea\x01\x08\x0e\n\r\n\x05\x04\x0e\x02\0\x01\x12\
    \x04\xea\x01\x0f\x11\n\r\n\x05\x04\x0e\x02\0\x03\x12\x04\xea\x01\x14\x15\
    \nJ\n\x02\x04\x0f\x12\x06\xf0\x01\0\xf1\x01\x01\x1a<*\n\x20Represents\
    \x20a\x20response\x20containing\x20the\x20did\x20deletion\x20event.\n\n\
    \x0b\n\x03\x04\x0f\x01\x12\x04\xf0\x01\x08\x19\n7\n\x02\x04\x10\x12\x06\
    \xf6\x01\0\xf8\x01\x01\x1a)*\n\x20Represents\x20a\x20request\x20to\x20ba\
    ckup\x20a\x20did.\n\n\x0b\n\x03\x04\x10\x01\x12\x04\xf6\x01\x08\x18\n,\n\
    \x04\x04\x10\x02\0\x12\x04\xf7\x01\x08\x16\"\x1e\x20The\x20ID\x20of\x20t\
    he\x20did\x20to\x20back\x20up\n\n\r\n\x05\x04\x10\x02\0\x05\x12\x04\xf7\
    \x01\x08\x0e\n\r\n\x05\x04\x10\x02\0\x01\x12\x04\xf7\x01\x0f\x11\n\r\n\
    \x05\x04\x10\x02\0\x03\x12\x04\xf7\x01\x14\x15\nO\n\x02\x04\x11\x12\x06\
    \xfd\x01\0\xff\x01\x01\x1aA*\n\x20Represents\x20a\x20response\x20contain\
    ing\x20the\x20did\x20backup\x20recovery\x20kit.\n\n\x0b\n\x03\x04\x11\
    \x01\x12\x04\xfd\x01\x08\x19\n,\n\x04\x04\x11\x02\0\x12\x04\xfe\x01\x08%\
    \"\x1e\x20The\x20recovery\x20kit\x20of\x20the\x20DID.\n\n\r\n\x05\x04\
    \x11\x02\0\x06\x12\x04\xfe\x01\x08\x13\n\r\n\x05\x04\x11\x02\0\x01\x12\
    \x04\xfe\x01\x14\x20\n\r\n\x05\x04\x11\x02\0\x03\x12\x04\xfe\x01#$\nN\n\
    \x02\x04\x12\x12\x06\x84\x02\0\x87\x02\x01\x1a@*\n\x20Represents\x20a\
    \x20request\x20to\x20recover\x20a\x20did\x20with\x20the\x20recovery\x20k\
    it.\n\n\x0b\n\x03\x04\x12\x01\x12\x04\x84\x02\x08\x19\n#\n\x04\x04\x12\
    \x02\0\x12\x04\x85\x02\x08%\"\x15\x20The\x20DID\x20to\x20recover.\n\n\r\
    \n\x05\x04\x12\x02\0\x06\x12\x04\x85\x02\x08\x13\n\r\n\x05\x04\x12\x02\0\
    \x01\x12\x04\x85\x02\x14\x20\n\r\n\x05\x04\x12\x02\0\x03\x12\x04\x85\x02\
    #$\n\xbf\x01\n\x04\x04\x12\x02\x01\x12\x04\x86\x02\x08'\"\xb0\x01\x20If\
    \x20using\x20the\x20recovery\x20kit\x20to\x20also\x20init\x20the\x20seed\
    \x20with\x20the\x20passed\x20in\x20mnenomic,\x20provide\x20a\x20passphra\
    se\x20to\x20encrypt\x20DB/seed\x20with.\x20Not\x20needed\x20if\x20`id.In\
    itSeed`\x20has\x20already\x20ran\x20before.\n\n\r\n\x05\x04\x12\x02\x01\
    \x04\x12\x04\x86\x02\x08\x10\n\r\n\x05\x04\x12\x02\x01\x05\x12\x04\x86\
    \x02\x11\x17\n\r\n\x05\x04\x12\x02\x01\x01\x12\x04\x86\x02\x18\"\n\r\n\
    \x05\x04\x12\x02\x01\x03\x12\x04\x86\x02%&\nK\n\x02\x04\x13\x12\x06\x8c\
    \x02\0\x8e\x02\x01\x1a=*\n\x20Represents\x20a\x20response\x20containing\
    \x20the\x20did\x20recovery\x20result.\n\n\x0b\n\x03\x04\x13\x01\x12\x04\
    \x8c\x02\x08\x1ab\x06proto3\
";

/// `FileDescriptorProto` object which was a source for this generated file
fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    static file_descriptor_proto_lazy: ::protobuf::rt::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::Lazy::new();
    file_descriptor_proto_lazy.get(|| {
        ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
    })
}

/// `FileDescriptor` object which allows dynamic access to files
pub fn file_descriptor() -> &'static ::protobuf::reflect::FileDescriptor {
    static generated_file_descriptor_lazy: ::protobuf::rt::Lazy<::protobuf::reflect::GeneratedFileDescriptor> = ::protobuf::rt::Lazy::new();
    static file_descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::FileDescriptor> = ::protobuf::rt::Lazy::new();
    file_descriptor.get(|| {
        let generated_file_descriptor = generated_file_descriptor_lazy.get(|| {
            let mut deps = ::std::vec::Vec::with_capacity(2);
            deps.push(super::annotations::file_descriptor().clone());
            deps.push(super::annotations::file_descriptor().clone());
            let mut messages = ::std::vec::Vec::with_capacity(20);
            messages.push(RecoveryKit::generated_message_descriptor_data());
            messages.push(ResolveDIDRequest::generated_message_descriptor_data());
            messages.push(ResolveDIDResponse::generated_message_descriptor_data());
            messages.push(StoreDIDRequest::generated_message_descriptor_data());
            messages.push(StoreDIDResponse::generated_message_descriptor_data());
            messages.push(ListDIDRequest::generated_message_descriptor_data());
            messages.push(ListDIDResponse::generated_message_descriptor_data());
            messages.push(ServiceEndpoint::generated_message_descriptor_data());
            messages.push(CreateDIDRequest::generated_message_descriptor_data());
            messages.push(CreateDIDResponse::generated_message_descriptor_data());
            messages.push(ImportDIDRequest::generated_message_descriptor_data());
            messages.push(ImportDIDResponse::generated_message_descriptor_data());
            messages.push(UpdateDIDRequest::generated_message_descriptor_data());
            messages.push(UpdateDIDResponse::generated_message_descriptor_data());
            messages.push(DeleteDIDRequest::generated_message_descriptor_data());
            messages.push(DeleteDIDResponse::generated_message_descriptor_data());
            messages.push(BackupDIDRequest::generated_message_descriptor_data());
            messages.push(BackupDIDResponse::generated_message_descriptor_data());
            messages.push(RecoverDIDRequest::generated_message_descriptor_data());
            messages.push(RecoverDIDResponse::generated_message_descriptor_data());
            let mut enums = ::std::vec::Vec::with_capacity(0);
            ::protobuf::reflect::GeneratedFileDescriptor::new_generated(
                file_descriptor_proto(),
                deps,
                messages,
                enums,
            )
        });
        ::protobuf::reflect::FileDescriptor::new_generated_2(generated_file_descriptor)
    })
}
